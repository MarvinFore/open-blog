


## 正则字符组

| 字符组 | 具体含义  | |
| ------ | ------ | ------ |
|---|字面量|
|\d|表示 [0-9]。表示是一位数字。 记忆方式:其英文是 digit(数字)。|
|\D|表示 [^0-9]。表示除数字外的任意字符。|
|\w|表示 [0-9a-zA-Z_]。表示数字、大小写字母和下划线。 记忆方式:w 是 word 的简写，也称单词字符。
|\W|表示 [^0-9a-zA-Z_]。非单词字符。
|\s|表示 [ \t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页 符。记忆方式:s 是 space 的首字母，空白符的单词是 white space。
|\S|表示 [^ \t\v\n\r\f]。 非空白符。
|.|表示 [^\n\r\u2028\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符 除外。 记忆方式:想想省略号 ... 中的每个点，都可以理解成占位符，表示任何类似的东西。
|\0|       匹配 NULL 字符。
|\t |      匹配水平制表符。
|\v|       匹配垂直制表符。
|\n  |     匹配换行符。
|\r|       匹配回车符。
|\f  |     匹配换页符。
|---|量词
|{n,m} |      连续出现 n 到 m 次。贪婪模式。 {n,}       至少连续出现 n 次。贪婪模式。 
|{n}|       连续出现 n 次。贪婪模式。
|?|       等价于 {0,1}。贪婪模式。
|+|       等价于 {1,}。贪婪模式。
|*|       等价于 {0,}。贪婪模式。
|{n,m}?    |   连续出现 n 到 m 次。惰性模式。 
|{n,}?|       至少连续出现 n 次。惰性模式。 {n}?       连续出现 n 次。惰性模式。
|??|       等价于 {0,1}?。惰性模式。
|+?|       等价于 {1,}?。惰性模式。
|*?|       等价于 {0,}?。惰性模式。
|---|位置匹配
|^ |      匹配开头的位置，当正则有修饰符 m 时，表示匹配行开头位置。
|$|       匹配结尾的位置，当正则有修饰符 m 时，表示匹配行结尾位置。
|\b|       匹配单词边界，即，\w 与 \W、^ 与 \w、\w 与 $ 之间的位置。
|\B|       匹配非单词边界，即，\w 与 \w、\W 与 \W、^ 与 \W，\W 与 $ 之间的位置。 
|(?=abc)  |     匹配 "abc" 前面的位置，即此位置后面匹配 "abc"。
|(?!abc) |      匹配非 "abc" 前面的位置，即此位置后面不匹配 "abc"。 |||括号的作用
|(ab)      | 捕获型分组。把 "ab" 当成一个整体，比如 (ab)+ 表示 "ab" 至少连续出现一次。 
|(?:ab)  |     非捕获型分组。与 (ab) 的区别是，它不捕获数据。
|(good/nice)|      /代表竖直线 捕获型分支结构。匹配 "good" 或 "nice"。
|(?:good/nice)| 非捕获型分支结构。与 (good/nice) 的区别是，它不捕获数据。
|\num|       反向引用。比如 \2，表示引用的是第二个括号里的捕获的数据。
|---|  修饰符
|g|       全局匹配，找到所有满足匹配的子串。
|i|       匹配过程中，忽略英文字母大小写。
|m|       多行匹配，把 ^ 和 $ 变成行开头和行结尾。
|---|  String相关实例方法
|search   |   返回正则匹配到的第一个子串在目标字符串中的下标位置。
|split|       以正则匹配到的子串，对目标字符串进行切分。返回一个数组。
|match  |     对目标字符串执行正则匹配操作，返回的匹配结果数组中包含具体的匹配信息。 replace       对目标字符串进行替换操作。正则是其第一个参数。返回替换后的字符串。
## 元字符转义

^、$、.、*、+、?、|、\、/、(、)、[、]、{、}、=、!、:、- ,

当匹配上面的字符本身时，可以一律转义:
```js
var string = "^$.*+?|\\/[]{}=!:-,";
var regex = /\^\$\.\*\+\?\|\\\/\[\]\{\}\=\!\:\-\,/;
console.log( regex.test(string) );
// => true
```
## 正则位置

* ^(脱字符)匹配开头，在多行匹配中匹配行开头。
* $(美元符号)匹配结尾，在多行匹配中匹配行结尾
* \b 是单词边界，具体就是 \w 与 \W 之间的位置，也包括 \w 与 ^ 之间的位置，和 \w 与 $ 之间的位置。
* \B 就是 \b 的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉 \b，剩下的都是 \B 的。 具体说来就是 \w 与 \w、 \W 与 \W、^ 与 \W，\W 与 $ 之间的位置。
* (?=p)，其中 p 是一个子模式，即 p 前面的位置，或者说，该位置后面的字符要匹配 p。比如 (?=l)，表示 "l" 字符前面的位置
* 而 (?!p) 就是 (?=p) 的反面意思
*  (?<=p) 和 (?<!p)。左右都是p和左右都不是p
## 正则api用法介绍
---
注：pattern 为RegExp的实例, str 为String的实例

| 用法 | 说明  |返回值
| ------ | ------ | ------ |
|pattern.test(str)|判断str是否包含匹配结果	|包含返回true，不包含返回false。
|pattern.exec(str)|根据pattern对str进行正则匹配|返回匹配结果数组,如匹配不到返回null
|str.match(pattern)|根据pattern对str进行正则匹配|返回匹配结果数组,如匹配不到返回null
|str.replace(pattern, replacement)|根据pattern进行正则匹配,把匹配结果替换为replacement|一个新的字符串
|str.search(pattern)|根据pattern进行正则匹配,返回匹配结果的索引值|数字索引
## RegExp对象方法
---
### test()
字符串的`test`方法，比较常用在判断语句中，最简单的RegExp方法了，用于检测一个字符串是否匹配某个模式：
```js
RegExpObject.test(string)
```
如果字符串 `string` 中含有与 `RegExpObject` 匹配的文本，则返回 true，否则返回 false：
```js
/\d/.test('asdf2') // --true   检测字符串`'asdf2'`中是否函数数字
```
### exec()
  
`exec()`方法功能非常强大，它是一个通用的方法方法，用于比较复杂的模式匹配或者是说你为你提供更多的信息：
```js
RegExpObject.exec(string)
```

如果在string中找到了匹配的文本，则返回一个包含这些文本的数组，否侧返回null。这里有几个注意的地方：

返回的数组的第一个元素是与整个正则匹配的文本;
然后,数组的第二个元素是与整个正则的第一个子表达式(分组)相匹配的文本;
数组的第三个元素整个正则的第二个子表达式(分组)相匹配的文本;
以此类推。。。

```js
var result = /(\d+)-(\w+)/.exec('12-ab');
console.log(result) // --> ["12-ab", "12", "ab", index: 0, input: "12-ab"] 
//为什么上面返回的“数组”是那么奇怪，按照[w3school][2]的说法就是：exec() 都会把完整的细节添加到它返回的数组中，这里的细节指的就是index和input
```

整个正则表达式匹配的文本：`"12-ab"`
第一个子表达式匹配的文本：`"12"`
第二个子表达式匹配的文本：`"ab"`

从上面返回的数组结果可知，数组添加了两个额外的属性，分别是：index, input

* index: 匹配文本的第一个字符的位置.
* input: 顾名思义，就是指输入的整体的文本了.

```js
console.log(result.index) // --> 0
console.log(result.input) // --> '12-ab'
```
执行`exec`函数时，尽管是全局匹配的正则表达式，但是`exec`方法只对指定的字符串进行一次匹配，获取字符串中第一个与正则表达式想匹配的内容，并且将匹配内容和子匹配的结果存储到返回的数组中。

返回的arr 的index属性一直为0，并且reg.lastIndex 下一次开始匹配的位置索引也一直为0



例如：`/\d/g.exec('a22') `，回的结果和上面的结果一样： ["2"]
```js
/\d/g.exec('a22') // -->["2"]
```

### 深入了解 exec()

深入前看看`RegExp`的**实例**有哪些属性：


* global: 布尔值，表示是否设置了 g 标志

* ignoreCase: 布尔值，表示是否设置了 i 标志

* lastIndex: 搜索下一个匹配项时开始的位置，从0开始

* multiline: 布尔值，表示是否设置了 m 标志

* source: 正则表达式的字符串表示

这里稍微陌生一点的就是`lastIndex`属性了，因为我们不会显示的需要用到它。但它还是挺重要的：

例1：

非全局匹配

```js
var reg = /\d/;

//第一次匹配
console.log(reg.exec('a123'));
console.log(reg.lastIndex);
//输出
["1",index:0,input:'a123']
  0
```
第二次匹配
```js
var arr = reg.exec('a123')
console.log(reg.exec('a123'));
console.log(reg.lastIndex);
//输出
["1",index:0,input:'a123']
0 
```
结论：

同一正则表达式，在非全局匹配模式下，每次实例的lastIndex属性的值总是不变的(为第一次开始找匹配文本所在的位置，上面默认为0 )；

每次的匹配查找都是将`lastIndex`作为起始位置的

并且 查找返回的arr.index 也一直没有改变，因为lastIndex一直没改变，查找的一直都是同一个匹配文本

例2：全局匹配

```js
var reg = /\d/g;
//第一次匹配
console.log(reg.exec('a123'));
console.log(reg.lastIndex);
//输出
["1",index:1,input:'a123']
  2
``` 
第二次匹配
```js
console.log(reg.exec('a123'));
console.log(reg.lastIndex);
//输出
["2",index:2,input:'a123']
  3 
```
第三次匹配
```js
console.log(reg.exec('a123'));
console.log(reg.lastIndex);
//输出
["3",index:3,input:'a123']
  4 
```
第四匹配
```js
console.log(reg.exec('a123'));
console.log(reg.lastIndex);
//输出
null
  0
```
结论：

同一正则表达式，在全局匹配模式下，每次实例的`lastIndex`属性的值为匹配文本最后一个字符的下一个位置，(即 index+匹配字符串的长度)

上面例子中第一次匹配的时候最后一个字符位置为1，则下一个位置为：2

当 `exec()` 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。

那当要获取全局匹配的全部匹配项时，可以通过循环来获取：
```js
var reg = /\d/g,
    result = [],
    crt;
while((crt = reg.exec('a123')) !== null){
    result = result.concat(crt)
};
console.log(result); //["1", "2", "3"]
```

## String对象方法

## 1. match()

`match() `方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。在一定程度上它与上面的exec()有些相似，看一下吧：

例1：非全局匹配
```js
var a = 'aaaa'.match(/\w/);
console.log(a); // ["a", index: 0, input: "aaaa"]
```
可以看到，和exec()一样，在数组中返回了index 和 input属性。

例2：全局匹配
```js
var a = 'aaaa'.match(/\w/g);
console.log(a); // ["a", "a", "a", "a"]
```
全局匹配就和exec方法有很大的不同了，他直接返回了所有符合匹配的子字符串的数组，另外，index和input属性也不在其中了，所以这个方法效率可能会高一些，但是如果你需要更多的信息，则用exec()吧

### 2. replace()

这也是一个比较灵活常用的方法，它用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。

这个方法接收两个必须的参数：

`pattern`: 这个参数可以是字符串或是RegExp对象

`replacement：` 替换匹配项的字符串或处理函数的返回值

返回结果：

当未找到匹配项的时候，返回原始字符串。
```js
    'aaaa'.replace('bbb', 'b')     //"aaaa"
```   
当pattern为字符串或者为非全局的RegExp对象的时候，只替换找到的第一项匹配项。
```js
    'aaaa'.replace('a', 'b')     //"baaa"
    'aaaa'.replace(/\w/, 'b')    //"baaa"
```
当pattern为全局的RegExp对象的时候，替换每一项匹配项。
```js
    'aaaa'.replace(/\w/g, 'b')    //"bbbb"
```
replacement：为函数时：
```js
'aaaa'.replace(/\w/g, function() {
    return 'b';
}); // "bbbb"

'aaaa'.replace(/\w/g, function(value) {
    return value.toUpperCase();
}); // "AAAA"
```
结论：

函数的返回值将作为替换字符串

函数的第一个参数的值是每一个匹配项,当然还有第二个参数，它的值是每个匹配项在原始字符串的中位置，从0开始

特殊的 `$`:

replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。

| 字符 | 替换文本  
| ------ | ------ 
|$1、$2、...、$99|与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。|
|$&	|与 regexp 相匹配的子串|
|$\`|	位于匹配子串左侧的文本|
|$\'|位于匹配子串右侧的文本|
|$$|美元符号|

来一发：

```js
//第一种情况：
'aa11AA'.replace(/([a-z]+)(\d+)([A-Z]+)/g, '$1'); // "aa"
'aa11AA'.replace(/([a-z]+)(\d+)([A-Z]+)/g, '$2'); // "11"
'aa11AA'.replace(/([a-z]+)(\d+)([A-Z]+)/g, '$3'); // "AA"
    //猜想 如果是 $4 回事什么呢？ undefined ? 
'aa11AA'.replace(/([a-z]+)(\d+)([A-Z]+)/g, '$4'); // "$4"
    //所以，要是没有该子项，则当成普通字符串处理了 
//第二种情况：
'aa11AA'.replace(/([a-z]+)(\d+)([A-Z]+)/g, '$&'); //"aa11AA"

//第三种情况：
'aa11AA'.replace(/(\d+)/g, '$`'); //"aaaaAA"

//第四种情况：
'aa11AA'.replace(/(\d+)/g, "$'"); //"aaAAAA"

//第五种情况：
'aa11AA'.replace(/(\d+)/g, '$$'); //"aa$AA"
```