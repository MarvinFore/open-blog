
### TCP报文格式：
---
![tcp包](https://raw.githubusercontent.com/jgchenu/staticAssets/master/web-learning/http3.png)

TCP 报文包括：`报头`跟`数据`

#### TCP报文的报头：
---
Sequence Number ：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。

Acknowledgement Number： ack序号，占32位，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到

标志位(保留六位)：共6个，即URG、ACK、PSH、RST、SYN、FIN

具体含义如下：
* （A）URG：该字段为1表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。
* （B）ACK：该字段为1表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。
* （C）PSH：该字段为1表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。
* （D）RST：该字段为1表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。
* （E）SYN：当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。
* （F）FIN：该字段为1示此报文段是一个释放连接的请求报文。

 Window Size:窗口大小，表示还能接收多少字节的数据，用于流量控制

 16位的源端口号跟目的端口号

 16位检验和 

 16位窗口大小

 16位紧急指针

总结：确认包的ack序号跟标志位的ACK不是指同一个，前者：ack序列号是32位的确认序号， ack=seq+1，期待收到的下一个tcp包的序列号，后者是标志位的ack位，为1 时候表示确认序号有效。


### TCP三次握手：
---

![三次握手](https://raw.githubusercontent.com/jgchenu/staticAssets/master/web-learning/http4.png)

首先假设主动发起请求的一端称为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP 连接建立完后都能发送和接收数据，所以 TCP 是一个全双工的协议。

起初，两端都为 CLOSED 状态。在通信开始前，双方都会创建 TCB。 服务器创建完 TCB 后便进入 LISTEN 状态，此时开始等待客户端发送数据。

**1.第一次握手**

客户端发送SYN报文（标志位SYN为1，表示发起一个新连接。seq=x,初始序号x保存在报头的序列号(Sequence Number)字段里),也称为ISN，客户端进入`SYN-SENT`阶段，然后服务器监听到请求链接，被动打开链接。

**2.第二次握手**

服务端接受到客户端发送过来的SYN报文之后，解析报文，服务器向客户端发回ACK报文(标志位ACK=1，表示确认序号有效。标志位SYN为1，表示发起一个新连接。ack=x+1,32位ack确认序号设置为x+1 即是第一次握手时SYN报文里面的seq(ISN)加上1。然后ACK报文的序列号(seq)设置为y，返回给客户端)应答,服务端进入`SYN-RCVD`状态。

**3.第三次握手**

客户端接受到服务端返回的ACK报文，解析报文，发送本次ACK报文。

发送的ACK报文中，`标志位SYN`为0,表示不用发起新连接，因为原先第一次握手已经建立了。`标志位ACK`为1，表示确认序号有效。
设置32位`确认序号ack`=ISN+1=y+1，32位`序号seq`=上一次返回的ACK报文的32位确认序号`ack即x+1`，发送ACK报文给服务端后，进入`ESTAB-LISHED`状态，服务端收到之后，进入`ESTAB-LISHED`状态，双方链接建立，开始数据传送

性能指标 RTT：该指标表示从发送端发送数据，到接收到服务端数据 所需的往返时间。

PS：第三次握手中可以包含数据，通过快速打开（TFO）技术就可以实现这一功能。其实只要涉及到握手的协议，都可以使用类似 TFO 的方式，客户端和服务端存储相同的 cookie，下次握手时发出 cookie 达到减少 RTT 的目的。

**为什么 TCP 建立连接需要三次握手，明明两次就可以建立起连接**

因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。

可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求，然后接收数据后释放了连接。

假设这时候连接请求 A 在两端关闭后终于抵达了服务端，那么此时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。但是客户端其实是 CLOSED 的状态，那么就会导致服务端一直等待，造成资源的浪费。

PS：在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次，在建立连接中可能会遇到 SYN Flood 攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求。

**由于TCP三次握手，常见SYN攻击手段**

SYN攻击在三次握手过程中：服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接，称为半连接(half-open connect).此时服务器处于SYN_RECV状态，当收到ACK后，服务器转入ESTABLISHED状态。

**Syn攻击**

就是 `攻击客户端 `在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。

Syn攻击是一个典型的DDOS攻击。检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击.在Linux下可以如下命令检测是否被SYN攻击
```
netstat -n -p TCP | grep SYN_RECV
```
一般较新的TCP/IP协议栈都对这一过程进行修正来防范Syn攻击，修改tcp协议实现。主要方法有`SynAttackProtect保护机制`、`SYN cookies技术`、`增加最大半连接和缩短超时时间`等,但是不能完全防范syn攻击。



### 四次挥手
---


![tcp包](https://raw.githubusercontent.com/jgchenu/staticAssets/master/web-learning/http5.png)

TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。

**1.第一次挥手**

假设Client端发起中断连接请求，也就是发送FIN报文。
Server端接到FIN报文后，clinet的意思是"我Client端没有数据要发给你了，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。"

**2.第二次挥手**

Server收到连接释放请求后，会告诉应用层要释放 TCP 链接,然后Server发送ACK报文，告诉Client端，"你的请求我收到了，我知道你没东西传给我了,但是我这边还没准备好，请继续你等我的消息"，并且Server进入`CLOSE_WAIT` 状态，此时表明 Client 到 Server 的连接已经释放，不再接收 Client 发的数据了,但是因为 TCP 连接是双向的，所以 Server 仍旧可以发送数据给 Client。



这个时候Client端就进入`FIN_WAIT`状态，继续等待Server端的FIN报文。

**3.第三次挥手**

此时Server有可能向client的传输数据还没结束，当Server端确定数据已发送完成，则向Client端发送FIN报文，告诉Client端"好了，我这边数据发完了，准备好关闭连接了"，发送FIN报文连接释放请求后 ，Server 便进入 LAST-ACK 状态。

PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送。

**4.第四次挥手**

Client端收到FIN报文后，就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK报文后进入`TIME_WAIT`状态。

Server端收到ACK报文后，就断开链接了，如果等待了一个MSL,Server端没有收到ACK报文则会发起重传。

Client端等待2个报文传输周期之后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！

>2个报文周期的计算：如果第四次握手的确认信息丢失，服务器将会重新发送第三次握手的断开连接的信号，而服务器发觉丢包（假设有确认信息的话要等待一个报文传输周期）与重新发送的断开连接到达主机的时间（一个报文传输周期）正好为 2 个报文传输周期。

### ARQ 协议
---

ARQ 协议也就是超时重传机制。通过确认和超时机制保证了数据的正确送达，ARQ 协议包含`停止等待 ARQ `和`连续 ARQ `两种协议。

#### 停止等待 ARQ

* 正常传输过程

  只要 Client 向 Server 发送一段报文，都要停止发送下一段报文并启动一个定时器，等待Server回应，Client在定时器时间内接收到Server端应答就取消定时器并发送下一段报文。

* 报文丢失或出错

  在报文传输的过程中可能会出现丢包。这时候超过定时器设定的时间就会再次发送丢失的数据直到Server端响应，所以需要每次都备份发送的数据。

  即使报文正常的传输到Server端，也可能出现在传输过程中报文出错的问题。这时候Server端会抛弃该报文并等待 Client 端重传。

  PS：一般定时器设定的时间都会大于一个 RTT 的平均时间。

* ACK 超时或丢失

  Server端传输的应答也可能出现丢失或超时的情况。那么超过定时器时间 Client 端照样会重传报文。这时候 Server 端收到相同序号的报文会丢弃该报文并重传应答，直到 Client 端发送下一个序号的报文。

在超时的情况下也可能出现应答很迟到达，这时 Server 端会判断该序号是否已经接收过，如果接收过只需要丢弃应答即可。

从上面的描述中大家肯定可以发现这肯定不是一个高效的方式。假设在良好的网络环境中，每次发送数据都需要等待片刻肯定是不能接受的。那么既然我们不能接受这个不那么高效的协议，就来继续学习相对高效的协议吧。

#### 连续 ARQ

* 在连续 ARQ 中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待 ARQ 协议来说减少了等待时间，提高了效率。

* 累计确认
  
  连续 ARQ 中，接收端会持续不断收到报文。如果和停止等待 ARQ 中接收一个报文就发送一个应答一样，就太浪费资源了。通过累计确认，可以在收到多个报文以后统一回复一个应答报文。报文中的 ACK 标志位可以用来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号后的数据。

  但是累计确认也有一个弊端。在连续接收报文时，可能会遇到接收到序号 5 的报文后，并未接收到序号 6 的报文，然而序号 7 以后的报文已经接收。遇到这种情况时，ACK 只能回复 6，因为要告诉发送端，序号6之前的数据已经全部接收到，但是这样就会造成发送端重复发送序号6跟序号7数据的情况。


### 滑动窗口

在上面小节中讲到了发送窗口。在 TCP 中，两端其实都维护着窗口：分别为`发送端窗口`和`接收端窗口`。

发送端窗口包含 已发送但未收到应答的数据 和 可以发送但是未发送的数据。

![tcp包](https://raw.githubusercontent.com/jgchenu/staticAssets/master/web-learning/http7.png)

发送端窗口是由接收窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。

当发送端接收到应答报文后，会随之将窗口进行滑动

![tcp包](https://raw.githubusercontent.com/jgchenu/staticAssets/master/web-learning/http8.png)

滑动窗口是一个很重要的概念，它帮助 TCP 实现了流量控制的功能。接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据，防止出现接收方带宽已满，但是发送方还一直发送数据的情况。

#### Zero 窗口

在发送报文的过程中，可能会遇到对端出现零窗口的情况。在该情况下，发送端会停止发送数据，并启动 persistent timer 。该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断 TCP 链接。

### 拥塞处理

拥塞处理和流量控制不同，流量控制是作用于接收方，保证接收方来得及接受数据。拥塞处理是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。

拥塞处理包括了四个算法，分别为：
* 慢开始
* 拥塞避免
* 快速重传
* 快速恢复。

#### 慢开始算法

慢开始算法，顾名思义，就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。想必大家都下载过资源，每当我们开始下载的时候都会发现下载速度是慢慢提升的，而不是一蹴而就直接拉满带宽。

慢开始算法步骤具体如下 

* 连接初始设置拥塞窗口（Congestion Window） 为 1 MSS（一个分段的最大数据量）
* 每过一个 RTT 就将窗口大小乘二
* 指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。

#### 拥塞避免算法

拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。

在传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞了，会马上进行以下步骤：

* 将阈值设为当前拥塞窗口的一半大小
* 将拥塞窗口设为 1 MSS
* 启动拥塞避免算法


### 快速重传
---
快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号。如果发送端收到三个重复的 ACK，无需等待定时器超时而是直接启动快速重传算法。

假如我有一个分段数据是 1 ~ 10 这十个序号的报文，发送过程中丢失了序号为 3 和 7 的报文，那么发1号报文，收到2号ACK报文，发2号报文，收到3号ACK报文，发4号报文收到3号ACK报文（一次ACK）,发完5号报文收到3号ACK报文（二次ACK），发完6号报文收到3号ACK报文（三次ACK）因为TCP是有滑动窗口的，他发送不是等回包来了才发下一个，发送方是一直不停的在发送报文。

快速重传具体算法分为两种：

#### TCP Taho 实现如下

* 将阈值设为当前拥塞窗口的一半大小
* 将拥塞窗口设为 1 MSS
* 重新开始慢开始算法
  
#### TCP Reno 实现如下

* 拥塞窗口减半
* 将阈值设为当前拥塞窗口大小
* 进入快恢复阶段（重发接受端需要的包，一旦收到一个新的 ACK 答复就退出该阶段），这种方式在丢失多个包的情况下就不那么好了
* 使用拥塞避免算法    
  
#### TCP New Reno 改进后的快恢复

TCP New Reno 算法改进了之前 TCP Reno 算法的缺陷。在之前，TCP Reno 算法的快恢复中只要收到一个新的 ACK 包，就会退出快恢复。

在 TCP New Reno 中，TCP 发送方先记下（有收到三个重复 ACK 的分段报文中）的最大序号。

假如我有一个分段数据是 1 ~ 10 这十个序号的报文，发送过程中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。

首先发送端只会收到 ACK 序号为 3 的应答，因为一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号，接受端接受到了序号为1，2的报文， 那么回复ack序号为2+1=3的确认报文，这时候发送端重发序号为 3 的报文，接收方顺利接收的话就会发送 ACK 序号为 7 的应答。这时候 TCP 知道 接收端 是有多个包未收到，发送端会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。