HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。

TLS 协议位于传输层之上，应用层之下。首次进行 TLS 协议传输需要两个 RTT ，接下来可以通过 Session Resumption 减少到一个 RTT。

在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。

#### 对称加密：

对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。

这种加密方式固然很好，但是问题就在于如何让双方知道秘钥。因为传输数据都是走的网络，如果将秘钥通过网络的方式传递的话，一旦秘钥被截获就没有加密的意义的。

#### 非对称加密：

有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。

这种加密方式就可以完美解决对称加密存在的问题。假设现在两端需要使用对称加密，那么在这之前，可以先使用非对称加密`对话秘钥`。

简单流程如下：首先服务端将公钥公布出去，那么客户端也就知道公钥了。接下来客户端创建一个秘钥，然后通过公钥加密并发送给服务端，服务端接收到密文以后通过私钥解密出正确的秘钥，这时候两端就都知道秘钥是什么了。

TLS 握手过程如下图：

![udp](https://raw.githubusercontent.com/jgchenu/staticAssets/master/web-learning/http9.png)

1.客户端发送请求，其中带入内容
* 支持的协议版本，比如TLS 1.0版。
* 一个客户端生成的随机数n1，稍后用于生成"对话密钥"。
* 支持的加密方法，比如RSA公钥加密。
* 支持的压缩方法。
PS：这里我们关注随机数n1就好。

2.服务端返回信息，其中内容：
* 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
* 一个服务器生成的随机数n2，稍后用于生成"对话密钥"。
* 确认使用的加密方法，比如RSA公钥加密。
* 包含公钥的数字证书

PS：这里我们关注随机数n2以及数字证书。

3.验证数字证书的有效性后，客户端回应，其中内容：

* 一个随机数n3。该随机数用数字证书公钥加密，防止被窃听。
* 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
* 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。

PS：此外，如果第二步中，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。这一步我们关注随机数n3。

4.服务器最后回应，其中内容：

* 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
* 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。

PS:此时客户端和服务端都有随机数n1，n2，n3三个随机数，客户端和服务端用商定的算法利用3个随机数生成一个对话秘钥（session key），随后的通信就用这个秘钥进行加密解密，保证通信过程不被别人监听或者窜改。所以唯一的风险点在于这个对话秘钥是否会被窃取，窃取的唯一方式也就是身份冒充，在上述四次握手阶段中窃取到对话秘钥。


* 通过以上步骤可知，在 TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。
>
>（1）生成对话密钥一共需要三个随机数。
>
>（2）握手之后的对话使用"对话密钥"加密（对称加密），服务器的公钥和私钥只用于加密和解密"对话密钥"（非对称加密），无其他作用。
>
>（3）服务器公钥放在服务器的数字证书之中。

PS：以上说明的都是 TLS 1.2 协议的握手情况，在 1.3 协议中，首次建立连接只需要一个 RTT，后面恢复连接不需要 RTT 了。

#### 如何防止身份冒充

1.冒充服务端

服务端有权威机构签名的数字证书，证书中带有公钥。所以：1.窜改公钥会破坏数字证书，客户端验证证书有效性便可确认；2.就算窃取到证书后伪装成服务端与用户通信，没有私钥就无法解密出随机数n3，也就无法利用n1，n2，n3生成对话秘钥，没有对话秘钥也就无法解密用户发送的数据包。

2.冒充客户端

对于有权限限制的服务，往往会要求验证客户端身份，这时一般使用客户端证书。由于客户端证书要发送到服务器进行验证，所以要么通信过程是加密的，要么客户端证书是动态的（即限制冒充者使用窃听得到的证书的使用时间，例如30秒，这样在冒充者真正窃取到证书的时候，多半证书已经过期了。服务器会知道这个动态的算法，所以能实时验证证书。例如U盾。），否则证书是可以伪造出来或者复制下来的。
